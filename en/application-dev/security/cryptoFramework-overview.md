# Crypto Framework Overview
The Cryptographic (Crypto for shot) Framework shields the implementation differences of third-party cryptographic algorithm libraries and implements encryption and decryption, digital signature and signature verification, and generation of the message authentication code (MAC), hashes, and secure random numbers. You can use the APIs provided by this framework to implement cipher development quickly.

> **NOTE**
>
> The Crypto Framework provides cryptographic operations, but not key management. It is used when temporary session keys are used only in the memory or the applications implement secure key storage. If the system is required to provide key management (such as key storage), use the [HUKS](huks-overview.md).

## Working Principles

The Crypto Framework provides components in the following layers:

- Interface layer: provides unified JavaScript interfaces externally.
- Plug-in layer: implements third-party algorithm libraries.
- Framework layer: flexibly loads plug-ins to adapt to third-party algorithm libraries and shield differences between these algorithm libraries.

## Basic Concepts

### Symmetric Keys

A symmetric key is a key used both to encrypt and decrypt data. In symmetric encryption, the sender converts information in plaintext into ciphertext using a key and certain algorithm for security purposes. The receiver converts the ciphertext into plaintext using the same key and algorithm.

- **AES key**

  Advanced Encryption Standard (AES) is the most common symmetric encryption algorithm. AES is a block cipher, which divides plaintext into fixed-length groups of bits, called blocks. A block is encrypted each time until the entire plaintext is encrypted. The block size in AES is 128 bits. That is, each block contains 16 bytes (8 bits/byte). The key length can be 128 bits, 192 bits, or 256 bits.

- **3DES key**

  Triple Data Encryption Standard (3DES), also called 3DESede or Triple DES, applies the DES cipher three times to each data block. It uses three 64-bit keys to encrypt a data block three times. Compared with DES, 3DES provides higher security due to longer key length, but lower processing speed. The AES is faster and more secure than 3DES.

- **SM4 key**

  ShangMi 4 (SM4) is a block cipher that has a key size and a block size of 128 bits each. Both the encryption and decryption of one block of data is composed of 32 rounds. A non-linear key scheduler is used to produce the round keys. The decryption uses the same round keys as for encryption, except that they are in reversed order.

- **HMAC key**

  Hash-based Message Authentication Code (HMAC) is a key-based message authentication code algorithm. It implements authentication using a shared secret instead of using a digital signature. The MAC generated can be used to verify the integrity and authenticity of the message. The length of the MAC generated by HMAC is fixed.

  An HMAC key can be of any length. If the length of the key is greater than the length of the digest algorithm information block, the one-way hash result of the key is used as the new key. If the length of the key is less than the length of the digest algorithm information block, 0s are padded at the end of the key as the new key. That is, the key length is the same as the length of the digest algorithm information block.

### Asymmetric Keys

In the asymmetric cryptography, a private and public key pair is required. The private key is used to encrypt the plaintext, and the public key is used to decrypt the ciphertext. The public key is public and open to anyone in the system, while the private key is private. For signing and signature verification, the private key is used to sign the plaintext, and the public key is used to verify the signature data.

- **RSA key**

  Rivest-Shamir-Adleman (RSA) is an asymmetric encryption algorithm widely used for secure data transmission. The security of RSA depends on the practical difficulty of factoring the product of two large primes.

  The RSA key parameters include the following integers:

  **n**: modulus, which is a public parameter of the private key and public key.

  **sk**: private exponent, which is often written as **d** in the formula.

  **pk**: public exponent, which is often written as **e** in the formula.

- **ECC key**

  Elliptic-curve cryptography (ECC) is a public-key encryption algorithm based on elliptic curve mathematics. It security is based on the assumption that it is infeasible to find the discrete logarithm of a random elliptic curve element with respect to a publicly known base point. The Crypto Framework provides capabilities for generating a variety of ECC keys.

  The ECC algorithm can be regarded as an operation of numbers defined in a special set. Currently, the Crypto Framework supports elliptic curves in the **Fp** field, where **p** indicates a prime. The **Fp** field is also called prime field.

  The ECC key parameters in the **Fp** field include the following:

  **p**: prime used to determine **Fp**.

  **a**, **b**: determine the elliptic curve equation.

  **g**: base point of the elliptic curve, which can be represented as **gx** or **gy**.

  **n**: order of the base point **g**.

  **h**: cofactor.

  **sk**: private key, which is a random integer less than **n**.

  **pk**: public key, which is a point on the elliptic curve. **pk** = **sk** x **g**.

- **DSA key**

  Digital Signature Algorithm (DSA) is a public-key algorithm based on the modular exponentiation and discrete logarithm problem. It is used for digital signatures and signature verification, but not for encryption and decryption. The Crypto Framework provides the capability of generating DSA keys of different lengths.

  The DSA key parameters include the following:

  **p**: prime modulus, whose length is an integer multiple of 64.

  **q**: prime factor of p – 1. The length varies depending on the length of **p**.

  **g**: g = (h ^ ((p – 1) / q)) mod p, where **h** is an integer greater than 1 and less than **p** minus 1.

  **sk**: private key, which is a randomly generated integer greater than 0 and less than **q**.

  **pk**: public key. pk = (g ^ sk) mod p

- **SM2 key**

  ShangMi 2 (SM2) is a public key cryptographic algorithm based on ECC. The key length is 256 bits. The SM2 algorithm uses the elliptic curves over the **Fp** field.

  The SM2 key parameters in the **Fp** field include the following:

  **p**: prime greater than 3, used to determine **Fp**.

  **a**, **b**: determine the elliptic curve equation.

  **g**: base point of the elliptic curve, which can be represented as **gx** or **gy**.

  **n**: order of the base point **g**.

  **h**: cofactor.

  **sk**: private key, which is a random integer less than **n**.

  **pk**: public key, which is a point on the elliptic curve. **pk** = **sk** x **g**.

- **Ed25519 key**

  Ed25519 is a digital signature algorithm based on EdDSA. The key is of 256 bits and is implemented using Edwards curves. Ed25519 is used for signing and signature verification, and cannot be used for encryption or decryption.

  The Ed25519 key parameters include the following:

  **sk**: private key, which is a 32-byte random value.

  **pk**: public key, a 32-byte value derived from the private key.

- **X25519 key**

  X25519 is a Diffie-Hellman key exchange algorithm used for key agreement.

  The X25519 key parameters include the following:

  **sk**: private key, which is a 32-byte random value.

  **pk**: public key, a 32-byte value derived from the private key.

- **DH key**

  DH is a Diffie-Hellman key agreement algorithm used to exchange the public key only. It provides forward secrecy, which protects the session keys against compromises even if the communication channel is intercepted.

  The DH key parameters include the following:

  **p**: a large prime used as a modulus of a finite field. It is shared by all communicating parties.

  **g**: a primitive root modulo **p**.

  **l**: length of the private key, in bits.

  **sk**: private key, which is a randomly generated value.

  **pk**: public key, which is calculated using common parameters (**p** and **g**) and the private key.

### Encryption and Decryption

- **Symmetric AES encryption and decryption**

  The algorithm library provides the following cipher modes of operation for AES: ECB, CBC, OFB, CFB, CTR, GCM, and CCM. AES is a block cipher, with a fixed block size of 128 bits. In actual applications, the last block of plaintext may be less than 128 bits and needs to be padded. The padding options are as follows:
  - **NoPadding**: no padding.
  - **PKCS5**: pads a block cipher with a block size of 8 bytes.
  - **PKCS7**: pads any block size from 1 to 255 bytes. The PKCS #7 padding scheme is the same as that of PKCS #5.

  > **NOTE**
  >
  > In ECB and CBC modes, the plaintext must be padded if its length is not an integer multiple of 128 bits.<br>
  > Since the plaintext is padded to the block size, the PKCS #5 and PKCS #7 used in the algorithm library use the block size as the padding length. That is, data is padded to 16 bytes in AES encryption.

- **Symmetric 3DES encryption and decryption**

  3DES encryption and decryption apply the DES cipher three times to each data block to obtain the ciphertext or plaintext.

  The algorithm library provides the following cipher modes of operation for 3DES encryption and decryption: ECB, CBC, OFB, and CFB. DES is a block cipher, with a fixed block size of 64 bits. In actual applications, the last block of plaintext may be less than 64 bits and needs to be padded. The padding options are as follows:
  - **NoPadding**: no padding.
  - **PKCS5**: pads a block cipher with a block size of 8 bytes.
  - **PKCS7**: pads any block size from 1 to 255 bytes. The PKCS #7 padding scheme is the same as that of PKCS #5.

  > **NOTE**
  >
  > In ECB and CBC modes, the plaintext must be padded if its length is not an integer multiple of 64 bits.<br>
  > Since the plaintext is padded to the block size, the PKCS #5 and PKCS #7 used in the algorithm library use the block size as the padding length. That is, data is padded to 8 bytes in 3DES encryption.

- **Symmetric SM4 encryption and decryption**

  The Crypto Framework provides the following SM4 encryption modes: ECB, CBC, CTR, OFB, CFB, and CFB128. SM4 is a block cipher, with a fixed block size of 128 bits. In actual applications, the last block of plaintext may be less than 128 bits and needs to be padded. The padding options are as follows:

  - **NoPadding**: no padding.
  - **PKCS5**: pads a block cipher with a block size of 8 bytes.
  - **PKCS7**: pads any block size from 1 to 255 bytes. The PKCS #7 padding scheme is the same as that of PKCS #5.

  > **NOTE**
  >
  > In ECB and CBC modes, the plaintext must be padded if its length is not an integer multiple of 128 bits.<br>
  > Since the plaintext is padded to the block size, the PKCS #5 and PKCS #7 used in the algorithm library use the block size as the padding length. That is, data is padded to 16 bytes in SM4 encryption.

- **Asymmetric RSA encryption and decryption**

  RSA is an asymmetric cipher, with fixed-length blocks. In actual applications, diverse padding modes are used. Currently, the Crypto Framework provides the following padding modes:
  - **NoPadding**: no padding. The length of the input or output data must be the same as that of the RSA key modulus.
  - **PKCS1**: RSAES-PKCS1-V1_5 mode in RFC3447 (corresponding to RSA_PKCS1_PADDING in OpenSSL). The RSA converts the source data D into an encryption block (EB). In encryption, the length of the input data must be less than or equal to the RSA key modulus minus 11. The length of the output data is the same as that of the RSA key modulus.
  - **PKCS1_OAEP**: RSAES-OAEP mode in RFC 3447 (corresponding to RSA_PKCS1_OAEP_PADDING in OpenSSL). It is a new padding mode developed by PKCS#1. In this mode, two digests (**md** and **mgf1_md**) need to be set. During encryption, the length of the input data must meet the following requirements:<br>Input data length < RSA key modulus – md length (bytes) – mgf1_md length (bytes) – 2<br>The length of the output data is the same as that of the RSA key modulus. You can also set the **pSource** byte stream to define the encoding input **P** filled by OAEP and obtain the parameters related to PKCS1_OAEP.<br>
  The **PKCS1_OAEP** parameters include the following:<br>
  **md**: message digest algorithm.<br>
  **mgf**: mask generation algorithm. Currently, only MGF1 is supported.<br>
  **mgf1_md**: mgf1 digest algorithm.<br>
  **pSource**: byte stream, which is the source for encoding input P in OAEP padding.

  > **NOTE**
  >
  > RSA key modulus = (RSA bits + 7)/8

- **Asymmetric SM2 encryption and decryption**

  SM2 is an asymmetric encryption algorithm based on ECC. The encryption length is fixed. Currently, the Crypto Framework supports encrypted data in C1C3C2 format and decryption of data in C1C3C2 format.

### Signing and Signature Verification

- **RSA** 

  The Crypto Framework provides the following padding modes for RSA signing and signature verification:
  - **PKCS1**: RSASSA-PKCS1-V1_5 mode in RFC3447 (corresponding to RSA_PKCS1_PADDING in OpenSSL). When this mode is used for signing and signature verification, the digest (**md**) must be set, the digest algorithm output length (bytes) must be less than the RSA key modulus.

  - **PSS**: RSASSA-PSS mode in RFC 3447 (corresponding to RSA_PKCS1_PSS_PADDING in OpenSSL). In this mode, two digests (**md** and **mgf1_md**) must be set, and the total length (bytes) of **md** and **mgf1_md** must be less than the RSA key modulus. In this mode, the salt length (**saltLen**, in bytes) can also be set, and PSS-related parameters can be obtained.

    The PSS parameters include the following:<br>
    **md**: message digest algorithm.<br>
    **mgf**: mask generation algorithm. Currently, only MGF1 is supported.<br>
    **mgf1_md**: digest algorithm used in the MGF1 algorithm.<br>
    **saltLen**: salt length, in bytes.<br>
    **trailer_field**: integer used for encoding. The value must be **1**.

  > **NOTE**
  >
  > RSA key modulus = (RSA bits + 7)/8

- **ECDSA**

  The Elliptic Curve Digital Signature Algorithm (ECDSA) is a digital signature algorithm that uses the ECC. Compared with the ordinary Discrete Logarithm Problem (DLP) and Integer Factorization Problem (IFP), the ECC provides a higher unit bit strength than other public-key cryptographic systems. The Crypto Framework provides the ECDSA that combines multiple elliptic curves and digest algorithms.

- **DSA**

  The DSA security is based on the difficulty of the DLP in integer finite field. The DSA has great compatibility and applicability.

- **SM2**

  SM2 is a digital signature algorithm based on ECC.


### Key Agreement

- **ECDH**

  Elliptic Curve Diffie-Hellman (ECDH) allows two parties to establish a shared secret over an insecure channel. The Crypto Framework provides a variety of ECDH capabilities based on the open-source algorithm library.

### Message Digest

The message digest (MD) algorithm allows a fixed-length digest to be generated from data of arbitrary size by using the hash algorithm. It is used to encrypt sensitive information because it is infeasible to invert or reverse the computation. The MD algorithm is also referred to as a hash algorithm or a one-way hash algorithm.
When the same digest algorithm is used, the generated digest (hash value) has the following features:

- The same message always results in the same hash value.
- The digest generated is of the fixed length no matter the length of messages. (The digest length is determined by the algorithm used).
- It is almost impossible to find two different messages with the same hash value. (The probability still exists, depending on the length of the digest.)

### HMAC

Hash-based Message Authentication Code (HMAC) is a key-based message authentication code algorithm. HMAC provides authentication using a shared secret instead of using a digital signature. The MAC generated can be used to verify the integrity and authenticity of the message. The length of the MAC generated by HMAC is fixed. Compared with MAC, HMAC introduces the shared secret, which ensures data correctness.

### Random Number

Random numbers are mainly used to generate temporary session keys or keys in asymmetric encryption. They are generated by a hardware random number generator or software-based pseudo-random number generator. In encryption and decryption, a secure random number generator must feature randomness, unrepeatability, and unpredictability. The random numbers generated by the Cryptography Secure Random Number Generator (CSPRNG) meet the requirements of cryptography security pseudo-randomness.

- Internal state<br>A value in the random number generator memory. The same internal state produces the same sequence of the random number.
- Seed<br>A number used to initialize the internal state of a pseudorandom number generator. The random number generator generates a series of random sequences based on the seeds.

### Key Derivation Function

A key derivation function is a cryptographic algorithm that derives one or more secrete keys from a secret value (such as a master key) by using a pseudorandom function. Key derivation functions can be used to stretch keys into longer keys or to obtain keys in the required format.

- **PBKDF2**

  Password-Based Key Derivation Function (PBKDF) is a key derivation function with a sliding computational cost. PBKDF Function 2 (PBKDF2) is part of the PKCS series, and its specifications are released in RFC 2898. PBKDF2 applies a pseudorandom function (PRF), such as HMAC, to an input password together with a salt value, and repeats the process multiple times to generate a derived key.

  The PBKDF2 has the following parameters:

  **PRF**: a pseudo-random function, such as HMAC.

  **password**: master password from which a key is derived.

  **salt**: salt value.

  **iterations**: number of iterations.

  **keySize**: length of the derived key, in bytes.

## Constraints

- The Crypto Framework does not support concurrent operations of multiple threads.
- Currently, the algorithm library supports only OpenSSL.
- For a key generated based on key parameters, the bigint type must be a positive number in big-endian format.
- The encryption and decryption algorithm library provides common algorithms. Some algorithms and specifications, such as MD5, are not applicable to security scenarios. You need to select the proper algorithms as required.

## Key Generation Specifications

A key can be generated based on either of the following specifications:
- String parameter: a parameter that describes the specifications of the key to generate in the form of a string.
- Key parameter: a key object constructed using the specific cryptographic specifications.

### AES Key Generation Specifications

- AES keys can be generated based on a string parameter.

  |Symmetric Key Algorithm|Key Length (Bit)|String Parameter|
  |---|---|---|
  |AES|128|AES128|
  |AES|192|AES192|
  |AES|256|AES256|

  > **NOTE**
  >
  > The string parameter, consisting of the symmetric key algorithm and the key length, specifies the key specifications when a symmetric key generator is created.

### 3DES Key Generation Specifications

- 3DES keys can be generated based on a string parameter.

  |Symmetric Key Algorithm|Key Length (Bit)|String Parameter|
  |---|---|---|
  |3DES|192|3DES192|

  > **NOTE**
  >
  > The string parameter, consisting of the symmetric key algorithm and the key length, specifies the key specifications when a symmetric key generator is created.

### RSA Key Generation Specifications

  > **NOTE**
  >
  > Since API version 10, RSA keys can be generated based on a key parameter.

- RSA keys can be generated based on a string parameter.

  |RSA Key Type|Number of Primes|String Parameter|
  |---|---|---|
  |RSA512|2|RSA512\|PRIMES_2|
  |RSA768|2|RSA768\|PRIMES_2|
  |RSA1024|2|RSA1024\|PRIMES_2|
  |RSA1024|3|RSA1024\|PRIMES_3|
  |RSA2048|2|RSA2048\|PRIMES_2|
  |RSA2048|3|RSA2048\|PRIMES_3|
  |RSA3072|2|RSA3072\|PRIMES_2|
  |RSA3072|3|RSA3072\|PRIMES_3|
  |RSA4096|2|RSA4096\|PRIMES_2|
  |RSA4096|3|RSA4096\|PRIMES_3|
  |RSA4096|4|RSA4096\|PRIMES_4|
  |RSA8192|2|RSA8192\|PRIMES_2|
  |RSA8192|3|RSA8192\|PRIMES_3|
  |RSA8192|4|RSA8192\|PRIMES_4|
  |RSA8192|5|RSA8192\|PRIMES_5|

  > **NOTE**
  >
  > The string parameter, consisting of the RSA key type and the number of primes, specifies the key specifications when an asymmetric key generator is created. When an RSA asymmetric key is generated, the default number of primes is 2 and the **PRIMES_2** parameter can be omitted.

- RSA keys can also be generated based on a key parameter. The following table lists the types of key parameters and cryptography specifications of each key parameter.

  |   |Common Parameter|Public Key Parameter|Private Key Parameter|Public/Private Key Pair Parameter|
  |---|---------|---|---|---|
  |n    |x   |√    |x   |√   |
  |pk|    |√    |    |√    |
  |sk|    |    |x   |√    |

  > **NOTE**
  >
  > The key parameter specifies the key specifications when an asymmetric key generator is created.<br>
  > The preceding table illustrates the composition of the key parameter used for generating an RSA key.<br>
    √ indicates the property used to construct the key parameter.<br>
    x indicates that the property that cannot be used to construct the key parameter.

  > **NOTE**
  >
  > 1. An RSA key cannot be generated based on the common parameter **n**.
  > 2. An RSA private key cannot be generated based on the private key parameter containing **n** and **sk**.

### ECC Key Generation Specifications

  > **NOTE**
  >
  > Since API version 10, ECC keys can be generated based on a key parameter.
  >
  > Since API version 11, brainpool curves are supported.
  >
  > Since API version 11, a key parameter can be generated based on the curve name.

- ECC keys can be generated based on a string parameter.

  |Asymmetric Key Algorithm|Key Length (Bit)|Curve Name|String Parameter|
  |---|---|---|---|
  |ECC|224|NID_secp224r1|ECC224|
  |ECC|256|NID_X9_62_prime256v1|ECC256|
  |ECC|384|NID_secp384r1|ECC384|
  |ECC|521|NID_secp521r1|ECC521|
  |ECC|160|NID_brainpoolP160r1|ECC_BrainPoolP160r1|
  |ECC|160|NID_brainpoolP160t1|ECC_BrainPoolP160t1|
  |ECC|192|NID_brainpoolP192r1|ECC_BrainPoolP192r1|
  |ECC|192|NID_brainpoolP192t1|ECC_BrainPoolP192t1|
  |ECC|224|NID_brainpoolP224r1|ECC_BrainPoolP224r1|
  |ECC|224|NID_brainpoolP224t1|ECC_BrainPoolP224t1|
  |ECC|256|NID_brainpoolP256r1|ECC_BrainPoolP256r1|
  |ECC|256|NID_brainpoolP256t1|ECC_BrainPoolP256t1|
  |ECC|320|NID_brainpoolP320r1|ECC_BrainPoolP320r1|
  |ECC|320|NID_brainpoolP320t1|ECC_BrainPoolP320t1|
  |ECC|384|NID_brainpoolP384r1|ECC_BrainPoolP384r1|
  |ECC|384|NID_brainpoolP384t1|ECC_BrainPoolP384t1|
  |ECC|512|NID_brainpoolP512r1|ECC_BrainPoolP512r1|
  |ECC|512|NID_brainpoolP512t1|ECC_BrainPoolP512t1|

  > **NOTE**
  >
  > The string parameter specifies the ECC key specifications when an asymmetric key generator is created.<br>
  > Currently, only ECC Fp curves are supported.

- ECC keys can also be generated based on a key parameter. The following table lists the types of key parameters and cryptography specifications of each key parameter.
  |   |Common Parameter|Public Key Parameter|Private Key Parameter|Public/Private Key Pair Parameter|
  |---|---|---|---|---|
  |fieldType|    √|    √|    √|    √|
  |p    |    √|    √|    √|    √|
  |a    |    √|    √|    √|    √|
  |b    |    √|    √|    √|    √|
  |g    |    √|    √|    √|    √|
  |n    |    √|    √|    √|    √|
  |h    |    √|    √|    √|    √|
  |pk    |    |    √|     |    √|
  |sk    |    |     |    √|    √|

  > **NOTE**
  >
  > The key parameter specifies the key specifications when an asymmetric key generator is created.<br>
  > The preceding table illustrates the composition of the key parameter used for generating an ECC key.<br>
  > √ indicates the property used to construct the key parameter.

  > **NOTE**
  >
  > 1. Currently, the ECC supports only the **Fp** field. Therefore, **fieldType** has a fixed value of **Fp**. **fieldType** and **p** constitute the property **field**, which supports only [ECFieldFp](../reference/apis/js-apis-cryptoFramework.md#ecfieldfp10) currently.
  > 2. **g** and **pk** are points on the ECC curve and belong to the [Point](../reference/apis/js-apis-cryptoFramework.md#point10) type. You need to specify the X and Y coordinates.

- Key parameters can be generated based on the curve name. The following table lists the generated key parameters.

  | Asymmetric Key Algorithm| Key Length (Bit)| Curve Name              | String Parameter          |
  | -------------- | --------------- | -------------------- | -------------------- |
  | ECC            | 224             | NID_secp224r1        | NID_secp224r1        |
  | ECC            | 256             | NID_X9_62_prime256v1 | NID_X9_62_prime256v1 |
  | ECC            | 384             | NID_secp384r1        | NID_secp384r1        |
  | ECC            | 521             | NID_secp521r1        | NID_secp521r1        |
  | ECC            | 160             | NID_brainpoolP160r1  | NID_brainpoolP160r1  |
  | ECC            | 160             | NID_brainpoolP160t1  | NID_brainpoolP160t1  |
  | ECC            | 192             | NID_brainpoolP192r1  | NID_brainpoolP192r1  |
  | ECC            | 192             | NID_brainpoolP192t1  | NID_brainpoolP192t1  |
  | ECC            | 224             | NID_brainpoolP224r1  | NID_brainpoolP224r1  |
  | ECC            | 224             | NID_brainpoolP224t1  | NID_brainpoolP224t1  |
  | ECC            | 256             | NID_brainpoolP256r1  | NID_brainpoolP256r1  |
  | ECC            | 256             | NID_brainpoolP256t1  | NID_brainpoolP256t1  |
  | ECC            | 320             | NID_brainpoolP320r1  | NID_brainpoolP320r1  |
  | ECC            | 320             | NID_brainpoolP320t1  | NID_brainpoolP320t1  |
  | ECC            | 384             | NID_brainpoolP384r1  | NID_brainpoolP384r1  |
  | ECC            | 384             | NID_brainpoolP384t1  | NID_brainpoolP384t1  |
  | ECC            | 512             | NID_brainpoolP512r1  | NID_brainpoolP512r1  |
  | ECC            | 512             | NID_brainpoolP512t1  | NID_brainpoolP512t1  |

  > **NOTE**
  >
  > The generated key parameters can be used as common parameters to generate public and private keys.


### DSA Key Generation Specifications

  > **NOTE**
  >
  > Since API version 10, the DSA algorithm is supported for key generation, signing, and signature verification.

- DSA keys can be generated based on a string parameter.

  |Asymmetric Key Algorithm|Key Length (Bit)|String Parameter|
  |---|---|---|
  |DSA|1024|DSA1024|
  |DSA|2048|DSA2048|
  |DSA|3072|DSA3072|

  > **NOTE**
  >
  > The string parameter, consisting of the asymmetric key algorithm and the key length, specifies the key specifications when an asymmetric key generator is created.

- DSA keys can also be generated based on a key parameter. The following table lists the types of key parameters and cryptography specifications of each key parameter.

  |   |Common Parameter|Public Key Parameter|Private Key Parameter|Public/Private Key Pair Parameter|
  |---|---------|---|---|---|
  |p    |√    |√    |x   |√   |
  |q    |√    |√    |x   |√   |
  |g    |√    |√    |x   |√   |
  |pk   |    |√    |    |√    |
  |sk   |    |     |x   |√    |

  > **NOTE**
  >
  > The key parameter specifies the key specifications when an asymmetric key generator is created.<br>
  > The preceding table illustrates the composition of the key parameter used for generating a DSA key. <br>
  > √ indicates the property used to construct the key parameter.<br>
  > x indicates that the property that cannot be used to construct the key parameter.

  > **NOTE**
  >
  > 1. A DSA private key cannot be generated based on the key parameter containing **p**, **q**, **g**, and **sk**.
  > 2. When common parameters (**p**, **q**, **g**) are specified to generate a DSA key pair, the DSA key length must be at least 1024 bits.

### SM2 Key Generation Specifications

> **NOTE**
>
> Since API version 10, SM2 keys can be randomly generated.
>
> Since API version 11, SM2 keys can be generated based on a key parameter.
>
> Since API version 11, a key parameter can be generated based on the curve name.

- SM2 keys can be generated based on a string parameter.

  |Asymmetric Key Algorithm|Key Length (Bit)|String Parameter|
  |---|---|---|
  |SM2|256|SM2_256|

  > **NOTE**
  >
  > The string parameter, consisting of the asymmetric key algorithm and key length with an underscore (_) in between, specifies the key specifications when an asymmetric key generator is created.

- SM2 keys can also be generated based on a key parameter. The following table lists the types of key parameters and cryptography specifications of each key parameter.

  |           | Common Parameter| Public Key Parameter| Private Key Parameter| Public/Private Key Pair Parameter|
  | --------- | -------- | -------- | -------- | ------------ |
  | fieldType | √        | √        | √        | √            |
  | p         | √        | √        | √        | √            |
  | a         | √        | √        | √        | √            |
  | b         | √        | √        | √        | √            |
  | g         | √        | √        | √        | √            |
  | n         | √        | √        | √        | √            |
  | h         | √        | √        | √        | √            |
  | pk        |          | √        |          | √            |
  | sk        |          |          | √        | √            |

  > **NOTE**
  >
  > The key parameter specifies the key specifications when an asymmetric key generator is created.<br>
  > The preceding table illustrates the composition of the key parameter used for generating an SM2 key. <br>
  > √ indicates the property used to construct the key parameter.

  > **NOTE**
  >
  > 1. Currently, SM2 supports only the **Fp** field. Therefore, **fieldType** has a fixed value of **Fp**. **fieldType** and **p** constitute the property **field**, which supports only [ECFieldFp](../reference/apis/js-apis-cryptoFramework.md#ecfieldfp10) currently.
  > 2. **g** and **pk** are points on the SM2 curve and belong to the [Point](../reference/apis/js-apis-cryptoFramework.md#point10) type. You need to specify the X and Y coordinates.

- Key parameters can be generated based on the curve name. The following table lists the generated parameters.

  | Asymmetric Key Algorithm| Key Length (Bit)| Curve Name | String Parameter|
  | -------------- | --------------- | ------- | ---------- |
  | SM2            | 256             | NID_sm2 | NID_sm2    |

  > **NOTE**
  >
  > The generated key parameters can be used as common parameters to generate public and private keys.

### Ed25519 Key Generation Specifications

> **NOTE**
>
> Since API version 11, Ed25519 keys can be generated randomly based on a key parameter.
>

- Ed25519 keys can be generated based on a string parameter.

  | Asymmetric Key Algorithm| String Parameter|
  | -------------- | ---------- |
  | ED25519        | Ed25519    |

  > **NOTE**
  >
  > The string parameter specifies the key specifications when an asymmetric key generator is created.

- Ed25519 keys can also be generated based on a key parameter. The following table lists the types of key parameters and cryptography specifications of each key parameter.

  |      | Public Key Parameter| Private Key Parameter| Public/Private Key Pair Parameter|
  | ---- | -------- | -------- | ------------ |
  | pk   | √        |          | √            |
  | sk   |          | √        | √            |
  
  > **NOTE**
  >
  > The key parameter specifies the key specifications when an asymmetric key generator is created.<br>
  > The preceding table illustrates the composition of the key parameter used for generating an Ed25519 key.<br>
  > √ indicates the property used to construct the key parameter.<br>
  > The Ed25519 key parameter does not have common parameters.
  
  > **NOTE**
  >
  > Currently, Ed25519 keys cannot be generated based on common parameters.

### X25519 Key Generation Specifications

> **NOTE**
>
> Since API version 11, X25519 keys can be generated randomly based on a key parameter.
>

- X25519 keys can be generated based on a string parameter.

  | Asymmetric Key Algorithm| String Parameter|
  | -------------- | ---------- |
  | X25519         | X25519     |

  > **NOTE**
  >
  > The string parameter specifies the key specifications when an asymmetric key generator is created. Currently, only 256-bit X25519 keys are supported.

- X25519 keys can also be generated based on a key parameter. The following table lists the types of key parameters and cryptography specifications of each key parameter.

  |      | Public Key Parameter| Private Key Parameter| Public/Private Key Pair Parameter|
  | ---- | -------- | -------- | ------------ |
  | pk   | √        |          | √            |
  | sk   |          | √        | √            |
  
  > **NOTE**
  >
  > The key parameter specifies the key specifications when an asymmetric key generator is created.<br>
  > The preceding table illustrates the composition of the key parameter used for generating an X25519 key.<br>
  > √ indicates the property used to construct the key parameter.<br>
  > The X25519 key parameter does not have common parameters.
  
  > **NOTE**
  >
  > Currently, X25519 keys cannot be generated based on common parameters.

### DH Key Generation Specifications

  > **NOTE**
  >
  > Since API version 11, DH keys can be generated randomly.
  >
  > Since API version 11, DH keys can be generated based on a key parameter.
  >
  > Since API version 11, DH key parameters can be generated based on the prime length and the private key length.

- DH keys can be generated based on a string parameter.

  | Asymmetric Key Algorithm| DH Group| Key Length (Bit)| String Parameter  |
  | -------------- | -------------- | --------------- | ------------ |
  | DH             | modp1536       | 1536            | DH_modp1536  |
  | DH             | modp2048       | 2048            | DH_modp2048  |
  | DH             | modp3072       | 3072            | DH_modp3072  |
  | DH             | modp4096       | 4096            | DH_modp4096  |
  | DH             | modp6144       | 6144            | DH_modp6144  |
  | DH             | modp8192       | 8192            | DH_modp8192  |
  | DH             | ffdhe2048      | 2048            | DH_ffdhe2048 |
  | DH             | ffdhe3072      | 3072            | DH_ffdhe3072 |
  | DH             | ffdhe4096      | 4096            | DH_ffdhe4096 |
  | DH             | ffdhe6144      | 6144            | DH_ffdhe6144 |
  | DH             | ffdhe8192      | 8192            | DH_ffdhe8192 |

  > **NOTE**
  >
  > The string parameter, consisting of the asymmetric key algorithm and the DH group with an underscore (_) in between, specifies the key specifications when an asymmetric key generator is created.

- DH keys can also be generated based on a key parameter. The following table lists the types of key parameters and cryptography specifications of each key parameter.

  |      | Common Parameter| Public Key Parameter| Private Key Parameter| Public/Private Key Pair Parameter|
  | ---- | -------- | -------- | -------- | ------------ |
  | p    | √        | √        | √        | √            |
  | l    | √        | √        | √        | √            |
  | g    | √        | √        | √        | √            |
  | pk   |          | √        |          | √            |
  | sk   |          |          | √        | √            |

  > **NOTE**
  >
  > 1. The key parameter specifies the key specifications when an asymmetric key generator is created.
  > 2. The preceding table illustrates the composition of the key parameter used for generating a DH key.
  > 3. √ indicates the property used to construct the key parameter.
  > 4. If the default value **0** of **l** is used, the length of the private key is not specified.

- Key parameters can be generated based on the prime length and private key length. If the prime length is the same as that of the DH group, the DH group is used. The following table lists the mappings between the prime lengths and DH groups.

  | Prime Length (Bit)| DH Group|
  | --------------- | -------------- |
  | 2048            | ffdhe2048      |
  | 3072            | ffdhe3072      |
  | 4096            | ffdhe4096      |
  | 6144            | ffdhe6144      |
  | 8192            | ffdhe8192      |
  
  > **NOTE**
  >
  > 1. The number of bits for **p** must be greater than or equal to 512 and less than or equal to 10000.
  > 2. The parameter **l** (private key length) is optional. The default value is **0**. The value of **l** must meet the following requirements:<br>**l** > 96 + (Length of **p** – 1)/1024 x 16
  > 3. Named DH groups are recommended because generating a key parameter with an unnamed DH group is time-consuming.
  

### SM4 Key Generation Specifications

> **NOTE**
>
> Since API version 10, SM4 keys can be randomly generated. 

- SM4 keys can be generated based on a string parameter.

  |Symmetric Key Algorithm|Key Length (Bit)|String Parameter|
  |---|---|---|
  |SM4|128|SM4_128|

  > **NOTE**
  >
  > The string parameter, consisting of the symmetric key algorithm and key length with an underscore (_) in between, specifies the key specifications when a symmetric key generator is created.

### HMAC Key Generation Specifications

> **NOTE**
>
> Since API version 11, HMAC keys can be generated.

- HMAC keys can be generated based on a string parameter.

  |Symmetric Key Algorithm|Digest algorithm|Key Length (Bit)|String Parameter|
  |---|---|---|---|
  |HMAC|SHA1|160|HMAC\|SHA1|
  |HMAC|SHA224|224|HMAC\|SHA224|
  |HMAC|SHA256|256|HMAC\|SHA256|
  |HMAC|SHA384|384|HMAC\|SHA384|
  |HMAC|SHA512|512|HMAC\|SHA512|
  |HMAC|SM3|256|HMAC\|SM3|
  |HMAC||[1, 32768]|HMAC|

  > **NOTE**
  >
  > 1. The string parameter, consisting of the symmetric key algorithm and MD algorithm with a vertical bar (|) in between, specifies the key specifications when a symmetric key generator is created.
  > 2. If the length of the key to be passed in is not within the range of the preceding digest algorithms, you can use the string parameter **HMAC** to create a symmetric key generator and generate a key based on the binary data of the HMAC key.

## Encryption and Decryption Specifications

### Symmetric Encryption and Decryption

  > **NOTE**
  >
  > Since API version 10, specifications without the key length are supported for symmetric encryption and decryption.

- The following symmetric encryption algorithms are supported.
  |Symmetric Encryption and Decryption Algorithm|Block Cipher Mode|String Parameter                                        |
  |---|---|---|
  |3DES|ECB|3DES192\|ECB\|[NoPadding\|PKCS5\|PKCS7]|
  |3DES|CBC|3DES192\|CBC\|[NoPadding\|PKCS5\|PKCS7]|
  |3DES|OFB|3DES192\|OFB\|[NoPadding\|PKCS5\|PKCS7]|
  |3DES|CFB|3DES192\|CFB\|[NoPadding\|PKCS5\|PKCS7]|
  |AES|ECB|AES[128\|192\|256]\|ECB\|[NoPadding\|PKCS5\|PKCS7]|
  |AES|CBC|AES[128\|192\|256]\|CBC\|[NoPadding\|PKCS5\|PKCS7]|
  |AES|CTR|AES[128\|192\|256]\|CTR\|[NoPadding\|PKCS5\|PKCS7]|
  |AES|OFB|AES[128\|192\|256]\|OFB\|[NoPadding\|PKCS5\|PKCS7]|
  |AES|CFB|AES[128\|192\|256]\|CFB\|[NoPadding\|PKCS5\|PKCS7]|
  |AES|GCM|AES[128\|192\|256]\|GCM\|[NoPadding\|PKCS5\|PKCS7]|
  |AES|CCM|AES[128\|192\|256]\|CCM\|[NoPadding\|PKCS5\|PKCS7]|
  |SM4|ECB|SM4_128\|ECB\|[NoPadding\|PKCS5\|PKCS7]|
  |SM4|CBC|SM4_128\|CBC\|[NoPadding\|PKCS5\|PKCS7]|
  |SM4|CTR|SM4_128\|CTR\|[NoPadding\|PKCS5\|PKCS7]|
  |SM4|OFB|SM4_128\|OFB\|[NoPadding\|PKCS5\|PKCS7]|
  |SM4|CFB|SM4_128\|CFB\|[NoPadding\|PKCS5\|PKCS7]|
  |SM4|CFB128|SM4_128\|CFB128\|[NoPadding\|PKCS5\|PKCS7]|

  > **NOTE**
  >
  > 1. The options included in the square brackets ([]) are mutually exclusive.
  > 2. The string parameter, consisting of the algorithm (including the key length), block cipher mode, and padding mode, specifies the symmetric encryption/decryption algorithm specifications when a symmetric encryption/decryption instance is created. 
  > 3. An underscore (_) must be added between SM4<sup>10+</sup> and the key length in **String Parameter**.

### **Asymmetric RSA Encryption and Decryption**

  > **NOTE**
  >
  > Since API version 10, specifications without the key length are supported for asymmetric RSA encryption and decryption.

The Crypto Framework provides three padding modes for RSA encryption/decryption: **NoPadding**, **PKCS1**, and **PKCS1_OAEP**.
- When **NoPadding** is used, the following parameters can be specified.

  |Asymmetric Key Type| Padding Mode| String Parameter|
  |---|---|---|
  |RSA512|NoPadding|RSA512\|NoPadding|
  |RSA768|NoPadding|RSA768\|NoPadding|
  |RSA1024|NoPadding|RSA1024\|NoPadding|
  |RSA2048|NoPadding|RSA2048\|NoPadding|
  |RSA3072|NoPadding|RSA3072\|NoPadding|
  |RSA4096|NoPadding|RSA4096\|NoPadding|
  |RSA8192|NoPadding|RSA8192\|NoPadding|
  |RSA|NoPadding|RSA\|NoPadding|

  > **NOTE**
  >
  > 1. The string parameter, consisting of the asymmetric key type and the padding mode, specifies the asymmetric encryption/decryption algorithm specifications when an asymmetric encryption/decryption instance is created.
  > 2. The RSA key type in the last row of the preceding table does not contain the key length to ensure compatibility with the key generated based on the key parameter. The encryption/decryption operation varies depending on the actual key length.

- If **PKCS1** is used, the following parameters can be specified.

  |Asymmetric Key Type| Padding Mode| String Parameter|
  |---|---|---|
  |RSA512|PKCS1|RSA512\|PKCS1|
  |RSA768|PKCS1|RSA768\|PKCS1|
  |RSA1024|PKCS1|RSA1024\|PKCS1|
  |RSA2048|PKCS1|RSA2048\|PKCS1|
  |RSA3072|PKCS1|RSA3072\|PKCS1|
  |RSA4096|PKCS1|RSA4096\|PKCS1|
  |RSA8192|PKCS1|RSA8192\|PKCS1|
  |RSA|PKCS1|RSA\|PKCS1|

  > **NOTE**
  >
  > 1. The string parameter, consisting of the asymmetric key type and the padding mode, specifies the asymmetric encryption/decryption algorithm specifications when an asymmetric encryption/decryption instance is created.
  > 2. The RSA key type in the last row of the preceding table does not contain the key length to ensure compatibility with the key generated based on the key parameter. The encryption/decryption operation varies depending on the actual key length.

- If **PKCS1_OAEP** is used, the following parameters can be specified.

  | Asymmetric Key Type| Padding Mode| Digest| Mask Digest|
  |---|---|---|---|
  |RSA512|PKCS1_OAEP|MD5|  [MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256]|
  |RSA512|PKCS1_OAEP|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256]|
  |RSA512|PKCS1_OAEP|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256]|
  |RSA512|PKCS1_OAEP|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224]
  |RSA768|PKCS1_OAEP|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA768|PKCS1_OAEP|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA768|PKCS1_OAEP|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA768|PKCS1_OAEP|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384]|
  |RSA768|PKCS1_OAEP|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256]|
  |RSA768|PKCS1_OAEP|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224]|
  |RSA1024|PKCS1_OAEP|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA1024|PKCS1_OAEP|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA1024|PKCS1_OAEP|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA1024|PKCS1_OAEP|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA1024|PKCS1_OAEP|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA1024|PKCS1_OAEP|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384]|
  |RSA2048|PKCS1_OAEP|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA2048|PKCS1_OAEP|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA2048|PKCS1_OAEP|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA2048|PKCS1_OAEP|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA2048|PKCS1_OAEP|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA2048|PKCS1_OAEP|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PKCS1_OAEP|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PKCS1_OAEP|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PKCS1_OAEP|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PKCS1_OAEP|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PKCS1_OAEP|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PKCS1_OAEP|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PKCS1_OAEP|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PKCS1_OAEP|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PKCS1_OAEP|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PKCS1_OAEP|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PKCS1_OAEP|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PKCS1_OAEP|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PKCS1_OAEP|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PKCS1_OAEP|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PKCS1_OAEP|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PKCS1_OAEP|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PKCS1_OAEP|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PKCS1_OAEP|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA|PKCS1_OAEP|MD algorithm that meets the requirements for length|MGF1_ digest algorithm that meets the requirements for length|

  > **NOTE**
  >
  > 1. The options included in the square brackets ([]) are mutually exclusive. The options outside the square brackets are fixed values.
  > 2. The string parameter, consisting of the asymmetric key type, padding mode, digest, and mask digest with a vertical bar (|) in between, specifies the asymmetric encryption and decryption algorithm specifications when an asymmetric encryption and decryption instance is created.<br>
  >    For example, **RSA2048|PKCS1_OAEP|SHA256|MGF1_SHA256**.
  > 3. The RSA key type in the last row of the preceding table does not contain the key length to ensure compatibility with the key generated based on the key parameter. The encryption/decryption operation varies depending on the actual key length.
  > 4. The input data must meet the following requirement:<br>Input data length < RSA key modulus - **md** length - **mgf1_md** length - 2<br>For example, if the RSA key is 512 bits, SHA-512 is not supported. For details about the definition of the RSA key modulus and digest length, see "Asymmetric RSA encryption and decryption" in [Encryption and Decryption](#encryption-and-decryption).

- When **PKCS1_OAEP** is used, you can obtain the [OAEP cipher parameter] (../reference/apis/js-apis-cryptoFramework.md#cipherspecitem10) and set the encoding input P for OAEP padding.

  | OAEP Parameter|Enum Value| Get()| Set()|
  |---|---|---|---|
  |md|OAEP_MD_NAME_STR |√|
  |mgf|OAEP_MGF_NAME_STR|√|
  |mgf1_md|OAEP_MGF1_MD_STR |√|
  |pSource|OAEP_MGF1_PSRC_UINT8ARR|√|√|

  > **NOTE**
  >
  > The preceding table presents the Get() and Set() capabilities for OAEP parameters supported by the Crypto Framework. **√** indicates that the parameter can be obtained or set.


### **Asymmetric SM2 Encryption and Decryption**

> **NOTE**
>
> Since API version 10, specifications without the key length are supported for asymmetric SM2 encryption and decryption.

The SM2 encryption and decryption support only the ciphertext in C1C3C2 format. The SM2 asymmetric encryption result consists of C1, C2, and C3. C1 is the elliptic curve points calculated based on the random number generated. C2 is the ciphertext data. C3 is the value calculated using the specified MD algorithm. The new SM standard support data in C1C3C2 format. Encryption without digest is not supported.
- The following parameters are supported.

  | Asymmetric Key Type| Digest| String Parameter|
  |---|---|---|
  |SM2_256|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512\|SM3]|SM2_256\|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512\|SM3]|
  |SM2|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512\|SM3]|SM2_256\|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512\|SM3]|

  > **NOTE**
  >
  >  The string parameter, consisting of the asymmetric key type and the padding mode, specifies the asymmetric encryption/decryption algorithm specifications when an asymmetric encryption/decryption instance is created.

## Signing and Signature Verification Specifications

### RSA Signing and Signature Verification

  > **NOTE**
  >
  > Since API version 10, specifications without the key length are supported for RSA signing and signature verification.

The Crypto Framework provides two padding modes for RSA signing and signature verification: **PKCS1** and **PSS**.

-  If **PKCS1** is used, the following parameters can be specified.

  | Asymmetric Key Type| Padding Mode| Digest| String Parameter|
  |---|---|---|---|
  |RSA512|PKCS1|[MD5\|SHA1\|SHA224\|SHA256\|SHA384]|RSA512\|PKCS1\|[MD5\|SHA1\|SHA224\|SHA256\|SHA384]|
  |RSA768|PKCS1|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|RSA768\|PKCS1\|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |RSA1024|PKCS1|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|RSA1024\|PKCS1\|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |RSA2048|PKCS1|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|RSA2048\|PKCS1\|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |RSA3072|PKCS1|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|RSA3072\|PKCS1\|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |RSA4096|PKCS1|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|RSA4096\|PKCS1\|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |RSA8192|PKCS1|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|RSA8192\|PKCS1\|[MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |RSA|PKCS1|MD algorithm that meets the requirements for length|RSA\|PKCS1\|MD algorithm that meets the requirements for length|

  > **NOTE**
  >
  > 1. The options included in the square brackets ([]) are mutually exclusive. The options outside the square brackets are fixed values.
  > 2. The RSA key type in the last row of the preceding table does not contain the key length to ensure compatibility with the key generated based on the key parameter. The signing or signature verification operation varies depending on the actual key length.
  > 3. During RSA signature verification, the output length of the digest algorithm must be less than the RSA key modulus. For example, if the RSA key is 512 bits, SHA-512 is not supported. For details, see "RSA signing and signature verification" in [Signing and Signature Verification](#signing-and-signature-verification).

- If **PSS** is used, the following parameters can be specified.

  | Asymmetric Key Type| Padding Mode| Digest| Mask Digest|
  |---|---|---|---|
  |RSA512|PSS|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256]|
  |RSA512|PSS|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256]|
  |RSA512|PSS|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256]|
  |RSA512|PSS|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224]|RSA512\|PSS\|SHA256\|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224]|
  |RSA768|PSS|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA768|PSS|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA768|PSS|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA768|PSS|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384]|
  |RSA768|PSS|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256]|
  |RSA768|PSS|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224]|
  |RSA1024|PSS|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA1024|PSS|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA1024|PSS|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA1024|PSS|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA1024|PSS|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA1024|PSS|SHA512| [MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384]|
  |RSA2048|PSS|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA2048|PSS|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA2048|PSS|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA2048|PSS|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA2048|PSS|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA2048|PSS|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PSS|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PSS|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PSS|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PSS|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PSS|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA3072|PSS|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PSS|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PSS|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PSS|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PSS|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PSS|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA4096|PSS|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PSS|MD5|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PSS|SHA1|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PSS|SHA224|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PSS|SHA256|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PSS|SHA384|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA8192|PSS|SHA512|[MGF1_MD5\|MGF1_SHA1\|MGF1_SHA224\|MGF1_SHA256\|MGF1_SHA384\|MGF1_SHA512]|
  |RSA|PSS|MD algorithm that meets the requirements for length|MGF1_ digest algorithm that meets the requirements for length|

  > **NOTE**
  >
  > 1. The options included in the square brackets ([]) are mutually exclusive. The options outside the square brackets are fixed values.
  > 2. The string parameter, consisting of the asymmetric key type, padding mode, digest, and mask digest with a vertical bar (|) in between, specifies the asymmetric signing or signature verification algorithm specifications when an asymmetric signing or signature verification instance is created.<br>
  >    For example, **RSA2048|PSS|SHA256|MGF1_SHA256**.
  > 3. The RSA key type in the last row of the preceding table does not contain the key length to ensure compatibility with the key generated based on the key parameter. The signing or signature verification operation varies depending on the actual key length.
  > 4. If PSS padding mode is used in RSA signing or signature verification, the total length (in bytes) of **md** and **mgf1_md** must be less than the RSA key modulus. For example, if the RSA key is 512 bits, **md** and **mgf1_md** cannot be SHA256 at the same time. For details about the definition of the RSA key modulus and digest length, see "RSA signing and signature verification" in [Signing and Signature Verification](#signing-and-signature-verification).

- If the PSS mode is used, you can obtain the PSS [parameter](../reference/apis/js-apis-cryptoFramework.md#signspecitem10) for signing or signature verification, and set the salt length (**saltLen**, in bytes) for the PSS.

  | PSS Parameter|Enum Value| Get()| Set()|
  |---|---|---|---|
  |md|PSS_MD_NAME_STR |√|
  |mgf|PSS_MGF_NAME_STR|√|
  |mgf1_md|PSS_MGF1_MD_STR |√|
  |saltLen|PSS_SALT_LEN_NUM|√|√|
  |trailer_field|PSS_TRAILER_FIELD_NUM|√|

  > **NOTE**
  >
  > The preceding table presents the Get() and Set() capabilities for PSS parameters supported by the Crypto Framework. **√** indicates that the parameter can be obtained or set.

### ECDSA Signing and Signature Verification

  > **NOTE**
  > Since API version 10, specifications without the key length are supported for ECDSA signing and signature verification.
  >
  > Since API version 11, brainpool signing and signature verification are supported.
- The following ECDSA parameters are supported.

  |Asymmetric Key Type|Digest|String Parameter|
  |---|---|---|
  |ECC224|[SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|ECC224\|[SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |ECC256|[SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|ECC256\|[SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |ECC384|[SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|ECC384\|[SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |ECC521|[SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|ECC521\|[SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |ECC|[SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|ECC\|[SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |ECC_BrainPoolP160r1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP160r1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP160t1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP160t1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP192r1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP192r1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP192t1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP192t1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP224r1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP224r1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP224t1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP224t1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP256r1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP256r1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP256t1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP256t1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP320r1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP320r1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP320t1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP320t1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP384r1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP384r1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP384t1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP384t1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP512r1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP512r1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|
  |ECC_BrainPoolP512t1|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|ECC_BrainPoolP512t1\|MD5\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512|

  > **NOTE**
  >
  > 1. The options included in the square brackets ([]) are mutually exclusive. The options outside the square brackets are fixed values.
  > 2. The string parameter, consisting of the asymmetric key type and digest with a vertical bar (|) in between, specifies the asymmetric signing or signature verification algorithm specifications when an asymmetric signing or signature verification instance is created.<br>
  >    For example, **ECC224|SHA256**.
  > 3. In the preceding table, the ECC key type in the **ECC** row does not contain the key length to ensure compatibility with the key generated based on the key parameter. The ECDSA signing or signature verification operation varies depending on the actual key length.

### DSA Signing and Signature Verification

  > **NOTE**
  >
  > Since API version 10, DSA signing and signature verification specifications are supported.

- The following DSA parameters are supported.

  |Asymmetric Key Type|Digest|String Parameter|
  |---|---|---|
  |DSA1024|[NoHash\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|DSA1024\|[NoHash\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |DSA2048|[NoHash\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|DSA2048\|[NoHash\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |DSA3072|[NoHash\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|DSA3072\|[NoHash\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|
  |DSA|[NoHash\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|DSA\|[NoHash\|SHA1\|SHA224\|SHA256\|SHA384\|SHA512]|

  > **NOTE**
  >
  > 1. The options included in the square brackets ([]) are mutually exclusive. The options outside the square brackets are fixed values.
  > 2. The string parameter, consisting of the asymmetric key type and digest with a vertical bar (|) in between, specifies the asymmetric signing or signature verification algorithm specifications when an asymmetric signing or signature verification instance is created.<br>
  >    For example, **DSA1024|SHA256**.
  > 3. The DSA key type in the last row of the preceding table does not contain the key length to ensure compatibility with the key generated based on the key parameter. The signing or signature verification operation varies depending on the actual key length.


### SM2 Signing and Signature Verification

> **NOTE**
>
> Since API version 10, SM2 signing and signature verification are supported.

- The following SM2 parameters are supported.

  |Asymmetric Key Type|Digest|String Parameter|
  |---|---|---|
  |SM2_256|SM3|SM2_256\|SM3|
  |SM2|SM3|SM2\|SM3|

  > **NOTE**
  >
  > 1. The options included in the square brackets ([]) are mutually exclusive. The options outside the square brackets are fixed values.
  > 2. The string parameter, consisting of the asymmetric key type and digest with a vertical bar (|) in between, specifies the asymmetric signing or signature verification algorithm specifications when an asymmetric signing or signature verification instance is created.
  > 3. Currently, SM2 signing and signature verification support only SM3 digest.

### Ed25519 Signing and Signature Verification

> **NOTE**
>
> Since API version 11, Ed25519 signing and signature verification are supported.

- The following Ed25519 parameters are supported.

  | Asymmetric Key Type| String Parameter|
  | -------------- | ---------- |
  | ED25519        | Ed25519    |

  > **NOTE**
  >
  > The Ed25519 signing and signature verification algorithms do not support digest settings or **update()**.

## Key Agreement Specifications

### ECDH

  > **NOTE**
  >
  > Since API version 10, ECDH specifications without the key length are supported.
  >
  > Since API version 11, brainpool curves are supported.

- The following ECDH parameters are supported.

  |Asymmetric Key Algorithm|String Parameter|
  |---|---|
  |ECC|ECC224|
  |ECC|ECC256|
  |ECC|ECC384|
  |ECC|ECC521|
  |ECC|ECC_BrainPoolP160r1|
  | ECC            | ECC_BrainPoolP160t1 |
  | ECC            | ECC_BrainPoolP192r1 |
  | ECC            | ECC_BrainPoolP192t1 |
  | ECC            | ECC_BrainPoolP224r1 |
  | ECC            | ECC_BrainPoolP224t1 |
  | ECC            | ECC_BrainPoolP256r1 |
  | ECC            | ECC_BrainPoolP256t1 |
  | ECC            | ECC_BrainPoolP320r1 |
  | ECC            | ECC_BrainPoolP320t1 |
  | ECC            | ECC_BrainPoolP384r1 |
  | ECC            | ECC_BrainPoolP384t1 |
  | ECC            | ECC_BrainPoolP512r1 |
  | ECC            | ECC_BrainPoolP512t1 |
  | ECC            | ECC                 |

  > **NOTE**
  >
  > 1. The string parameter specifies the key agreement algorithm specifications when a key agreement instance is created.
  > 2. The ECC key type in the last row of the preceding table does not contain the key length to ensure compatibility with the key generated based on the key parameter. The ECDH key agreement operation varies depending on the actual key length.

### X25519

  > **NOTE**
  >
  > Since API version 11, X25519 key agreement is supported.

- The following X25519 parameters are supported.

  | Asymmetric Key Algorithm| String Parameter|
  | -------------- | ---------- |
  | X25519         | X25519     |

  > **NOTE**
  >
  > The string parameter specifies the key agreement algorithm specifications when a key agreement instance is created.

### DH

  > **NOTE**
  >
  > Since API version 11, DH specifications without the key length are supported.

- The following DH parameters are supported.

  | Asymmetric Key Algorithm| String Parameter  |
  | -------------- | ------------ |
  | DH             | DH_modp1536  |
  | DH             | DH_modp2048  |
  | DH             | DH_modp3072  |
  | DH             | DH_modp4096  |
  | DH             | DH_modp6144  |
  | DH             | DH_modp8192  |
  | DH             | DH_ffdhe2048 |
  | DH             | DH_ffdhe3072 |
  | DH             | DH_ffdhe4096 |
  | DH             | DH_ffdhe6144 |
  | DH             | DH_ffdhe8192 |
  | DH             | DH           |
  
  > **NOTE**
  >
  > 1. The string parameter specifies the key agreement algorithm specifications when a key agreement instance is created.
  > 2. If a key agreement object is created based on the string parameter, which is **DH**, key agreement using an unnamed DH group is supported.

## MD Algorithm Specifications

- The Crypto Framework supports the following MD algorithm parameters.

    > **NOTE**
    >
    > SM3 is supported since API version 10.

  |Digest algorithm|Supported Type|
  |---|---|
  |HASH|SHA1|
  |HASH|SHA224|
  |HASH|SHA256|
  |HASH|SHA384|
  |HASH|SHA512|
  |HASH|MD5|
  |HASH|SM3|

  > **NOTE**
  >
  > **Supported Type** specifies the MD algorithm specifications when an MD instance is created.

## HMAC Algorithm Specifications

- The Crypto Framework supports the following HMAC algorithm parameters:

    > **NOTE**
    >
    > SM3 is supported since API version 10.

  |Digest algorithm|Supported Type|
  |---|---|
  |HASH|SHA1|
  |HASH|SHA224|
  |HASH|SHA256|
  |HASH|SHA384|
  |HASH|SHA512|
  |HASH|SM3|

  > **NOTE**
  >
  > **Supported Type** specifies the HMAC algorithm specifications when an HMAC instance is created.

## Random Number Specifications
- Currently, the Crypto Framework supports only the CTR_DRBG algorithm.

  > **NOTE**
  >
  > 1. Currently, only secure random numbers with length of 1 to **INT_MAX** bytes are supported.
  > 2. The random number generation algorithm uses the **RAND_priv_bytes** interface of OpenSSL to generate secure random numbers.

## Key Derivation Function Specifications

### PBKDF2

> **NOTE**
>
> PBKDF2 is supported since API version 11.

- The Crypto Framework supports the following PBKDF2 parameters.

  |Key Derivation Function|HMAC Function Digest Algorithm|String Parameter|
  |---|---|---|
  |PBKDF2|SHA1|PBKDF2\|SHA1|
  |PBKDF2|SHA224|PBKDF2\|SHA224|
  |PBKDF2|SHA256|PBKDF2\|SHA256|
  |PBKDF2|SHA384|PBKDF2\|SHA384|
  |PBKDF2|SHA512|PBKDF2\|SHA512|
  |PBKDF2|SM3|PBKDF2\|SM3|

  > **NOTE**
  >
  > The string parameter, consisting of the key derivation function and HMAC digest algorithm with a vertical bar (|) in between, specifies the algorithm specifications when a key derivation function generator is created.
